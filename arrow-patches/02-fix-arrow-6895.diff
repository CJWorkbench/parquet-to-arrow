diff --git a/cpp/src/arrow/array/builder_dict.cc b/cpp/src/arrow/array/builder_dict.cc
index 511719662..0714f4c68 100644
--- a/cpp/src/arrow/array/builder_dict.cc
+++ b/cpp/src/arrow/array/builder_dict.cc
@@ -95,7 +95,6 @@ class internal::DictionaryMemoTable::DictionaryMemoTableImpl {
     std::shared_ptr<DataType> value_type_;
     MemoTable* memo_table_;
     MemoryPool* pool_;
-    int64_t start_offset_;
     std::shared_ptr<ArrayData>* out_;
 
     template <typename T>
@@ -109,7 +108,7 @@ class internal::DictionaryMemoTable::DictionaryMemoTableImpl {
       using ConcreteMemoTable = typename internal::DictionaryTraits<T>::MemoTableType;
       auto memo_table = static_cast<ConcreteMemoTable*>(memo_table_);
       return internal::DictionaryTraits<T>::GetDictionaryArrayData(
-          pool_, value_type_, *memo_table, start_offset_, out_);
+          pool_, value_type_, *memo_table, out_);
     }
   };
 
@@ -140,9 +139,8 @@ class internal::DictionaryMemoTable::DictionaryMemoTableImpl {
     return static_cast<BinaryMemoTable*>(memo_table_.get())->GetOrInsert(value);
   }
 
-  Status GetArrayData(MemoryPool* pool, int64_t start_offset,
-                      std::shared_ptr<ArrayData>* out) {
-    ArrayDataGetter visitor{type_, memo_table_.get(), pool, start_offset, out};
+  Status GetArrayData(MemoryPool* pool, std::shared_ptr<ArrayData>* out) {
+    ArrayDataGetter visitor{type_, memo_table_.get(), pool, out};
     return VisitTypeInline(*type_, &visitor);
   }
 
@@ -212,9 +210,9 @@ int32_t internal::DictionaryMemoTable::GetOrInsert(const util::string_view& valu
   return impl_->GetOrInsert(value);
 }
 
-Status internal::DictionaryMemoTable::GetArrayData(MemoryPool* pool, int64_t start_offset,
+Status internal::DictionaryMemoTable::GetArrayData(MemoryPool* pool,
                                                    std::shared_ptr<ArrayData>* out) {
-  return impl_->GetArrayData(pool, start_offset, out);
+  return impl_->GetArrayData(pool, out);
 }
 
 Status internal::DictionaryMemoTable::InsertValues(const Array& array) {
diff --git a/cpp/src/arrow/array/builder_dict.h b/cpp/src/arrow/array/builder_dict.h
index 665867a2a..e31cf25f2 100644
--- a/cpp/src/arrow/array/builder_dict.h
+++ b/cpp/src/arrow/array/builder_dict.h
@@ -72,8 +72,7 @@ class ARROW_EXPORT DictionaryMemoTable {
   int32_t GetOrInsert(const double& value);
   int32_t GetOrInsert(const util::string_view& value);
 
-  Status GetArrayData(MemoryPool* pool, int64_t start_offset,
-                      std::shared_ptr<ArrayData>* out);
+  Status GetArrayData(MemoryPool* pool, std::shared_ptr<ArrayData>* out);
 
   /// \brief Insert new memo values
   Status InsertValues(const Array& values);
@@ -108,7 +107,6 @@ class DictionaryBuilderBase : public ArrayBuilder {
       MemoryPool* pool = default_memory_pool())
       : ArrayBuilder(pool),
         memo_table_(new internal::DictionaryMemoTable(value_type)),
-        delta_offset_(0),
         byte_width_(-1),
         indices_builder_(pool),
         value_type_(value_type) {}
@@ -120,7 +118,6 @@ class DictionaryBuilderBase : public ArrayBuilder {
       MemoryPool* pool = default_memory_pool())
       : ArrayBuilder(pool),
         memo_table_(new internal::DictionaryMemoTable(value_type)),
-        delta_offset_(0),
         byte_width_(static_cast<const T1&>(*value_type).byte_width()),
         indices_builder_(pool),
         value_type_(value_type) {}
@@ -135,7 +132,6 @@ class DictionaryBuilderBase : public ArrayBuilder {
                         MemoryPool* pool = default_memory_pool())
       : ArrayBuilder(pool),
         memo_table_(new internal::DictionaryMemoTable(dictionary)),
-        delta_offset_(0),
         byte_width_(-1),
         indices_builder_(pool),
         value_type_(dictionary->type()) {}
@@ -233,18 +229,12 @@ class DictionaryBuilderBase : public ArrayBuilder {
     ArrayBuilder::Reset();
     indices_builder_.Reset();
     memo_table_.reset(new internal::DictionaryMemoTable(value_type_));
-    delta_offset_ = 0;
   }
 
   Status Resize(int64_t capacity) override {
     ARROW_RETURN_NOT_OK(CheckCapacity(capacity, capacity_));
     capacity = std::max(capacity, kMinBuilderCapacity);
 
-    if (capacity_ == 0) {
-      // Initialize hash table
-      // XXX should we let the user pass additional size heuristics?
-      delta_offset_ = 0;
-    }
     ARROW_RETURN_NOT_OK(indices_builder_.Resize(capacity));
     capacity_ = indices_builder_.capacity();
     return Status::OK();
@@ -257,15 +247,13 @@ class DictionaryBuilderBase : public ArrayBuilder {
     // Generate dictionary array from hash table contents
     std::shared_ptr<ArrayData> dictionary_data;
 
-    ARROW_RETURN_NOT_OK(
-        memo_table_->GetArrayData(pool_, delta_offset_, &dictionary_data));
+    ARROW_RETURN_NOT_OK(memo_table_->GetArrayData(pool_, &dictionary_data));
 
     // Set type of array data to the right dictionary type
     (*out)->type = type();
     (*out)->dictionary = MakeArray(dictionary_data);
 
     // Update internals for further uses of this DictionaryBuilder
-    delta_offset_ = memo_table_->size();
     indices_builder_.Reset();
 
     return Status::OK();
@@ -277,9 +265,6 @@ class DictionaryBuilderBase : public ArrayBuilder {
 
   Status Finish(std::shared_ptr<DictionaryArray>* out) { return FinishTyped(out); }
 
-  /// is the dictionary builder in the delta building mode
-  bool is_building_delta() { return delta_offset_ > 0; }
-
   std::shared_ptr<DataType> type() const override {
     return ::arrow::dictionary(indices_builder_.type(), value_type_);
   }
@@ -287,7 +272,6 @@ class DictionaryBuilderBase : public ArrayBuilder {
  protected:
   std::unique_ptr<DictionaryMemoTable> memo_table_;
 
-  int32_t delta_offset_;
   // Only used for FixedSizeBinaryType
   int32_t byte_width_;
 
diff --git a/cpp/src/arrow/array/dict_internal.cc b/cpp/src/arrow/array/dict_internal.cc
index 96f4c8b7f..6c979fb55 100644
--- a/cpp/src/arrow/array/dict_internal.cc
+++ b/cpp/src/arrow/array/dict_internal.cc
@@ -101,7 +101,7 @@ class DictionaryUnifierImpl : public DictionaryUnifier {
     // Build unified dictionary array
     std::shared_ptr<ArrayData> data;
     RETURN_NOT_OK(DictTraits::GetDictionaryArrayData(pool_, value_type_, memo_table_,
-                                                     0 /* start_offset */, &data));
+                                                     &data));
     *out_dict = MakeArray(data);
     return Status::OK();
   }
diff --git a/cpp/src/arrow/array/dict_internal.h b/cpp/src/arrow/array/dict_internal.h
index 6c6c9c721..87b2e1ebf 100644
--- a/cpp/src/arrow/array/dict_internal.h
+++ b/cpp/src/arrow/array/dict_internal.h
@@ -64,18 +64,13 @@ struct DictionaryTraits<BooleanType> {
   static Status GetDictionaryArrayData(MemoryPool* pool,
                                        const std::shared_ptr<DataType>& type,
                                        const MemoTableType& memo_table,
-                                       int64_t start_offset,
                                        std::shared_ptr<ArrayData>* out) {
-    if (start_offset < 0) {
-      return Status::Invalid("invalid start_offset ", start_offset);
-    }
-
     BooleanBuilder builder(pool);
     const auto& bool_values = memo_table.values();
     const auto null_index = memo_table.GetNull();
 
     // Will iterate up to 3 times.
-    for (int64_t i = start_offset; i < memo_table.size(); i++) {
+    for (int64_t i = 0; i < memo_table.size(); i++) {
       RETURN_NOT_OK(i == null_index ? builder.AppendNull()
                                     : builder.Append(bool_values[i]));
     }
@@ -92,23 +87,22 @@ struct DictionaryTraits<T, enable_if_has_c_type<T>> {
   static Status GetDictionaryArrayData(MemoryPool* pool,
                                        const std::shared_ptr<DataType>& type,
                                        const MemoTableType& memo_table,
-                                       int64_t start_offset,
                                        std::shared_ptr<ArrayData>* out) {
     std::shared_ptr<Buffer> dict_buffer;
-    auto dict_length = static_cast<int64_t>(memo_table.size()) - start_offset;
+    auto dict_length = static_cast<int64_t>(memo_table.size());
     // This makes a copy, but we assume a dictionary array is usually small
     // compared to the size of the dictionary-using array.
     // (also, copying the dictionary values is cheap compared to the cost
     //  of building the memo table)
     RETURN_NOT_OK(
         AllocateBuffer(pool, TypeTraits<T>::bytes_required(dict_length), &dict_buffer));
-    memo_table.CopyValues(static_cast<int32_t>(start_offset),
+    memo_table.CopyValues(static_cast<int32_t>(0),
                           reinterpret_cast<c_type*>(dict_buffer->mutable_data()));
 
     int64_t null_count = 0;
     std::shared_ptr<Buffer> null_bitmap = nullptr;
     RETURN_NOT_OK(
-        ComputeNullBitmap(pool, memo_table, start_offset, &null_count, &null_bitmap));
+        ComputeNullBitmap(pool, memo_table, 0, &null_count, &null_bitmap));
 
     *out = ArrayData::Make(type, dict_length, {null_bitmap, dict_buffer}, null_count);
     return Status::OK();
@@ -122,32 +116,31 @@ struct DictionaryTraits<T, enable_if_binary<T>> {
   static Status GetDictionaryArrayData(MemoryPool* pool,
                                        const std::shared_ptr<DataType>& type,
                                        const MemoTableType& memo_table,
-                                       int64_t start_offset,
                                        std::shared_ptr<ArrayData>* out) {
     std::shared_ptr<Buffer> dict_offsets;
     std::shared_ptr<Buffer> dict_data;
 
     // Create the offsets buffer
-    auto dict_length = static_cast<int64_t>(memo_table.size() - start_offset);
+    auto dict_length = static_cast<int64_t>(memo_table.size());
     if (dict_length > 0) {
       RETURN_NOT_OK(AllocateBuffer(
           pool, TypeTraits<Int32Type>::bytes_required(dict_length + 1), &dict_offsets));
       auto raw_offsets = reinterpret_cast<int32_t*>(dict_offsets->mutable_data());
-      memo_table.CopyOffsets(static_cast<int32_t>(start_offset), raw_offsets);
+      memo_table.CopyOffsets(static_cast<int32_t>(0), raw_offsets);
     }
 
     // Create the data buffer
     auto values_size = memo_table.values_size();
     if (values_size > 0) {
       RETURN_NOT_OK(AllocateBuffer(pool, values_size, &dict_data));
-      memo_table.CopyValues(static_cast<int32_t>(start_offset), dict_data->size(),
+      memo_table.CopyValues(static_cast<int32_t>(0), dict_data->size(),
                             dict_data->mutable_data());
     }
 
     int64_t null_count = 0;
     std::shared_ptr<Buffer> null_bitmap = nullptr;
     RETURN_NOT_OK(
-        ComputeNullBitmap(pool, memo_table, start_offset, &null_count, &null_bitmap));
+        ComputeNullBitmap(pool, memo_table, 0, &null_count, &null_bitmap));
 
     *out = ArrayData::Make(type, dict_length, {null_bitmap, dict_offsets, dict_data},
                            null_count);
@@ -163,25 +156,24 @@ struct DictionaryTraits<T, enable_if_fixed_size_binary<T>> {
   static Status GetDictionaryArrayData(MemoryPool* pool,
                                        const std::shared_ptr<DataType>& type,
                                        const MemoTableType& memo_table,
-                                       int64_t start_offset,
                                        std::shared_ptr<ArrayData>* out) {
     const T& concrete_type = internal::checked_cast<const T&>(*type);
     std::shared_ptr<Buffer> dict_data;
 
     // Create the data buffer
-    auto dict_length = static_cast<int64_t>(memo_table.size() - start_offset);
+    auto dict_length = static_cast<int64_t>(memo_table.size());
     auto width_length = concrete_type.byte_width();
     auto data_length = dict_length * width_length;
     RETURN_NOT_OK(AllocateBuffer(pool, data_length, &dict_data));
     auto data = dict_data->mutable_data();
 
-    memo_table.CopyFixedWidthValues(static_cast<int32_t>(start_offset), width_length,
-                                    data_length, data);
+    memo_table.CopyFixedWidthValues(static_cast<int32_t>(0), width_length, data_length,
+                                    data);
 
     int64_t null_count = 0;
     std::shared_ptr<Buffer> null_bitmap = nullptr;
     RETURN_NOT_OK(
-        ComputeNullBitmap(pool, memo_table, start_offset, &null_count, &null_bitmap));
+        ComputeNullBitmap(pool, memo_table, 0, &null_count, &null_bitmap));
 
     *out = ArrayData::Make(type, dict_length, {null_bitmap, dict_data}, null_count);
     return Status::OK();
diff --git a/cpp/src/arrow/compute/kernels/hash.cc b/cpp/src/arrow/compute/kernels/hash.cc
index e07cedbe7..ce127d899 100644
--- a/cpp/src/arrow/compute/kernels/hash.cc
+++ b/cpp/src/arrow/compute/kernels/hash.cc
@@ -295,7 +295,7 @@ class RegularHashKernelImpl : public HashKernelImpl {
 
   Status GetDictionary(std::shared_ptr<ArrayData>* out) override {
     return DictionaryTraits<Type>::GetDictionaryArrayData(pool_, type_, *memo_table_,
-                                                          0 /* start_offset */, out);
+                                                          out);
   }
 
   template <typename Enable = Status>
diff --git a/cpp/src/parquet/arrow/reader_internal.cc b/cpp/src/parquet/arrow/reader_internal.cc
index 7b803fa26..f295faf11 100644
--- a/cpp/src/parquet/arrow/reader_internal.cc
+++ b/cpp/src/parquet/arrow/reader_internal.cc
@@ -801,7 +801,7 @@ Status TransferDictionary(RecordReader* reader,
                           std::shared_ptr<ChunkedArray>* out) {
   auto dict_reader = dynamic_cast<internal::DictionaryRecordReader*>(reader);
   DCHECK(dict_reader);
-  *out = dict_reader->GetResult();
+  *out = dict_reader->ReleaseResult();
   if (!logical_value_type->Equals(*(*out)->type())) {
     RETURN_NOT_OK((*out)->View(logical_value_type, out));
   }
diff --git a/cpp/src/parquet/column_reader.cc b/cpp/src/parquet/column_reader.cc
index df33eeeb6..5f1e8d4b7 100644
--- a/cpp/src/parquet/column_reader.cc
+++ b/cpp/src/parquet/column_reader.cc
@@ -1259,9 +1259,11 @@ class ByteArrayDictionaryRecordReader : public TypedRecordReader<ByteArrayType>,
     this->read_dictionary_ = true;
   }
 
-  std::shared_ptr<::arrow::ChunkedArray> GetResult() override {
+  std::shared_ptr<::arrow::ChunkedArray> ReleaseResult() override {
     FlushBuilder();
-    return std::make_shared<::arrow::ChunkedArray>(result_chunks_, builder_.type());
+    auto chunks = std::make_shared<::arrow::ChunkedArray>(result_chunks_, builder_.type());
+    result_chunks_.clear();
+    return chunks;
   }
 
   void FlushBuilder() {
@@ -1269,9 +1271,6 @@ class ByteArrayDictionaryRecordReader : public TypedRecordReader<ByteArrayType>,
       std::shared_ptr<::arrow::Array> chunk;
       PARQUET_THROW_NOT_OK(builder_.Finish(&chunk));
       result_chunks_.emplace_back(std::move(chunk));
-
-      // Reset clears the dictionary memo table
-      builder_.Reset();
     }
   }
 
@@ -1280,6 +1279,8 @@ class ByteArrayDictionaryRecordReader : public TypedRecordReader<ByteArrayType>,
       /// If there is a new dictionary, we may need to flush the builder, then
       /// insert the new dictionary values
       FlushBuilder();
+      // Reset clears the dictionary memo table
+      builder_.Reset();
       auto decoder = dynamic_cast<BinaryDictDecoder*>(this->current_decoder_);
       decoder->InsertDictionary(&builder_);
       this->new_dictionary_ = false;
diff --git a/cpp/src/parquet/column_reader.h b/cpp/src/parquet/column_reader.h
index 2b6ec9f36..06fb9cab3 100644
--- a/cpp/src/parquet/column_reader.h
+++ b/cpp/src/parquet/column_reader.h
@@ -289,7 +289,9 @@ class BinaryRecordReader : virtual public RecordReader {
 /// indices). Only valid for BYTE_ARRAY columns
 class DictionaryRecordReader : virtual public RecordReader {
  public:
-  virtual std::shared_ptr<::arrow::ChunkedArray> GetResult() = 0;
+  /// \brief Transfer DictionaryArray chunks to caller. New chunks will
+  /// be allocated in subsequent ReadRecords calls
+  virtual std::shared_ptr<::arrow::ChunkedArray> ReleaseResult() = 0;
 };
 
 static inline void DefinitionLevelsToBitmap(
